/*
 * IntermedTableMemoryImpl.java
 *
 * Created on 17. September 2003, 13:16
 */
package de.cismet.jpresso.core.kernel;

import de.cismet.jpresso.core.exceptions.NoValuesException;
import de.cismet.jpresso.core.serviceprovider.exceptions.JPressoException;
import de.cismet.jpresso.core.utils.TypeSafeCollections;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.List;
import java.util.Map;
import javax.swing.event.TableModelEvent;

/** 
 * This class represents a RAM-based implementation of an IntermedTable.
 * 
 * @author srichter
 * 
 */
public final class IntermedTableMemoryImpl extends IntermedTable {

    /** Container der die Daten aufnimmt */
    private final List<String[]> memTable;
    /** Container der Daten speichert die schon einmal in der Datenbank gefunden wurden*/
    //sprich: tatsaechlich schon in der datenbank drinstehen
    private final List<String[]> foundInDbTable;
    //indexes for faster normalization lookups
    private final Map<Integer, Integer> tableIndex;
    private final Map<Integer, Integer> dbIndex;
    //
    private final boolean normalize;

    /**
     * Creates a new instance of IntermedTableMemoryImpl
     *
     * @param enclChars Array der Zeichen die bei einem Vergleich oder Insert um den jeweiligen String
     * kommen. In der Regel ' oder Blank
     * @param targetConn Connection zum Zielsystem
     * @param tableName Tabellenname der Zieltabelle
     * @param targetFields Spaletnnamen der Zieltabelle
     */
    @SuppressWarnings("unchecked") //can not compromise
    public IntermedTableMemoryImpl(final String tableName, final String[] targetFields, final String[] enclChars, final int[] compareFields, final Connection targetConn, final int[] autoIncFields, final boolean deleteOrphaned) {
        super(targetFields, enclChars, compareFields, tableName, targetConn, autoIncFields, deleteOrphaned);
        this.targetConn = targetConn;
        memTable = TypeSafeCollections.newArrayList();
        foundInDbTable = TypeSafeCollections.newArrayList();
        tableIndex = TypeSafeCollections.newHashMap();
        dbIndex = TypeSafeCollections.newHashMap();
        if (compareFields != null && compareFields.length > 0) {
            normalize = true;
        } else {
            normalize = false;
        }
        setColumnNameToNumberMapping(targetFields);
        log.debug("setColumnNameToNumberMapping(targetFields):" + this.columnNameToNumberMapping);
    }

    @Override
    public void setValueAt(final Object aValue, final int row, final int column) {
        if (row < getRowCount() && column < columnNames.length) {
            if (aValue != null) {
                memTable.get(row)[column] = aValue.toString();
            } else {
                memTable.get(row)[column] = null;
            }
            fireTableChanged(new TableModelEvent(this, row, row, column));
        } else {
            log.error("Accessing not existing table element: (" + row + ", " + column + ")!");
        }
    }

    /** 
     * Liefert den neuesten Wert in der angegebenen Spalte
     * 
     * @param column Spaltennummer
     * @throws NoValuesException NoValuesException Exception wird geworfen wenn keine Daten an entsprechender Stelle vorhanden sind
     * @return Wert der Zelle als String
     */
    @Override
    public String[] getNextAutogeneratedValues() {
        final String[] result = new String[getAutoIncFields().length];
        for (int i = 0; i < getAutoIncFields().length; ++i) {
            if (memTable.size() == 0) {
                result[i] = getNextValueFromDB(getAutoIncFields()[i]);
            } else {
                result[i] = String.valueOf(++counterValues[autoIncFields[i]]);
            }
        }
        return result;
    }

    //used in container
    /** 
     * Fuegt der IntermedTableMemoryImpl eine neue Zeile an
     * @param rowData String[] der neuen Zeile
     * @throws JPressoException wird geworfen falls die Laenge des
     * uebergebenen Arrays nicht mit der Anzahl der
     * Spalten der Zieltabelle uebereinstimmt
     */
    @Override
    public void addRow(final String[] rowData) {
        memTable.add(rowData);
        if (normalize) {
            tableIndex.put(generateMultiStringHashCode(rowData), memTable.size() - 1);
        }
    }

    /** 
     * Fuellt die Hashtabel columnNameToNumberMapping
     * 
     * @param columnNames String[] der Spaltennamen
     */
    private void setColumnNameToNumberMapping(final String[] columnNames) {
        columnNameToNumberMapping.clear();
        for (int i = 0; i < columnNames.length; ++i) {
            columnNameToNumberMapping.put(columnNames[i], i);
        }
    }

    /** 
     * ueberprueft ob der uebergebene Datensatz schon in der Datenstruktur vorkommt.
     * Entscheidende Methode zur Realisierung der Normalisierungsfunktionalitaet.
     * Diese Methode untersucht nur die Hauptspeicherstruktur.
     * Es werden nur Spalten zum Vergleich herangezogen die in fields[] angegeben sind.
     * @return Falls eine uebereinstimmung gefunden wurde wird die entsprechende
     * Zeile zurueckgegeben, um z.B. die entsprechende ID zu erhalten.
     * @param container Gibt an in welchem Container gesucht wird
     * @param fields int[] indem die Spaltennummern angegeben werden die zum Vergleich
     * herangezogen werden
     * @param data <B>komplette</B> Zeile die ueberprueft werden soll
     */
    private String[] searchForRow(final String[] data, final List<String[]> container, int startIndex) {
        if (container == null) {
            return null;
        }
        //search in reverse order, as it is more likely to find a matching item
        //shortly inserted before - performance tuning
        for (int i = startIndex - 1; i < -1; --i) {
//        for (int i = 0; i < container[0].size(); ++i) {
            boolean newRow = false;
            String a, b;
            for (final int j : compareFields) {
                a = data[j];
                b = container.get(i)[j];
                if (a != null) {
                    if (!a.equals(b)) {
                        newRow = true;
                        break;
                    }
                } else if (b != null) {
                    newRow = true;
                    break;
                }
            }
            if (!newRow) {
                // Alles klar eine ganze zeile hat uebereingestimmt
                return container.get(i);
            }
        }
        return null;
    }

    /**
     * Generates a hashcode for a row, according to the given comparefields
     *
     * @param input
     * @return
     */
    private final int generateMultiStringHashCode(final String[] input) {
        if (input == null) {
            return 0;
        }
        int result = 1;
        String element;
        for (int i = 0; i < compareFields.length; ++i) {
            element = input[compareFields[i]];
            int elementHash = 0;
            if (element != null) {
                elementHash = element.hashCode();
            }
            result = 31 * result + elementHash;
        }
        return result;
    }

    /**
     * Test to see if two rows are equal with regards to their comparefields
     * 
     * @param one
     * @param two
     * @return
     */
    private final boolean areRowsEqual(final String[] one, final String[] two) {
        String a, b;
        if (one == two) {
            return true;
        } else if (one == null) {
            return false;
        }
        if (one.length != two.length) {
            return false;
        }
        for (final int j : compareFields) {
            a = one[j];
            b = two[j];
            if (a != null) {
                if (!a.equals(b)) {
                    return false;
                }
            } else if (b != null) {
                return false;
            }
        }
        return true;
    }

    /**
     * 
     * @param requested
     * @param container
     * @param indexMap
     * @return
     */
    private final String[] indexLookup(final int index, final String[] requested, final List<String[]> container) {
        final String[] ret = container.get(index);
        if (!areRowsEqual(requested, ret)) {
            return null;
        } else {
            return ret;
        }
    }

    /** 
     * Ueberprueft ob der uebergebene Datensatz schon in der Datenstruktur vorkommt.
     * Entscheidende Methode zur Realisierung der Normalisierungsfunktionalitaet.
     * Diese Methode untersucht nur die Hauptspeicherstruktur.
     * Es werden nur Spalten zum Vergleich herangezogen die in fields[] angegeben sind.
     * 
     * @param fields int[] indem die Spaltennummern angegeben werden die zum Vergleich
     * herangezogen werden
     * @param data <B>komplette</B> Zeile die ueberprueft werden soll
     * @param alsoInDatabase ist dieses Flag auf true gesetzt, wird nicht nur der momentane Import-
     * datenbestand fuer einen Vergleich ueberprueft, sondern auch die echte
     * Zieltabelle (Datenbank) ueberprueft.
     * @return Falls eine uebereinstimmung gefunden wurde wird die entsprechende
     * Zeile zurueckgegeben, um z.B. die entsprechende ID zu erhalten.
     * 
     * Genutzt vom IntermedTablesContainer.
     */
    @Override
    public String[] searchForRow(final String[] data, boolean alsoInDatabase) {
        //Datensatz im Hauptspeicher suchen. Zuerst den HashCode berechnen:
        final int dataHashCode = generateMultiStringHashCode(data);
        //Zuerst 체ber den Index
        final Integer indexMem = tableIndex.get(dataHashCode);
        String[] ret = null;
        if (indexMem != null) {
            ret = indexLookup(indexMem, data, memTable);
        }
        if (ret == null) {
            //Fehlerschlag: ggf noch ueber den DB-Cache Index
            final Integer indexDB = dbIndex.get(dataHashCode);
            if (alsoInDatabase) {
                if (indexDB != null) {
                    ret = indexLookup(indexDB, data, foundInDbTable);
                }
            }
            if (ret == null) {
                //Sonst komplett in allen in den bereits eingetragenen Zeilen der Speichertabelle suchen,
                //wenn der Hashtest ergeben hat, dass die Zeile 체berhaupt dort sein KOENNTE (indexM != null)
                if (indexMem != null) {
                    //Wir durchsuchen den Speicher nur oberhalb von indexMem, da
                    //dort der letzte Wert liegt der auf den gleichen Wert wie
                    //unsere gesuchte Zeile hashed. (Garantiert duch Funktions-
                    //weise von addRow(final String[] rowData))
                    ret = searchForRow(data, memTable, indexMem);
                }
                //wir muessen wenn alsoInDatabase == true ist auch in der Datenbank nachsehen
                if (ret == null && alsoInDatabase) {
                    //zuerst in der Merkertabelle f체r alles was schon in der Datenbank nachgeschaut wurde
                    //Wurde der Datensatz schon in der Datenbank gefunden? (Gibt nur Sinn wenn die Zeile
                    //schon gehashed wurde)
                    if (indexDB != null) {
                        //auch hier gilt wie bei indexMem: Suche beginnt
                        //oberhalb unseres gehashten Index
                        ret = searchForRow(data, foundInDbTable, indexDB);
                    }
                    if (ret == null) {
                        //und zuletzt noch in der datenbank nachschauen
                        try {
                            ret = searchForRowInTargetDb(data, dataHashCode);
                        } catch (JPressoException ex) {
                            //erst mal nix machen
                            String msg = "Normalizing error on DB: " + ex.getMessage() + ".\n Possible missing quotes on String/Date\nor waste quotes on non-String/Date value?";
                            log.warn(msg);
                        }
                    }
                }
            }
        }
        return ret;
    }

    /** 
     * Ueberprueft ob der uebergebene Datensatz schon in der Datenbank vorkommt.
     * Entscheidende Methode zur Realisierung der Normalisierungsfunktionalitaet.
     * Diese Methode untersucht nur die Datenbank
     * Es werden nur Spalten zum Vergleich herangezogen die in fields[] angegeben sind.
     * 
     * @param fields int[] indem die Spaltennummern angegeben werden die zum Vergleich
     * herangezogen werden
     * @param data <B>komplette</B> Zeile die ueberprueft werden soll
     * @throws JPressoException wird geworfen, wenn ein Fehler auftritt (DB, ...)
     * @return Falls eine Uebereinstimmung gefunden wurde wird die entsprechende
     * Zeile zurueckgegeben, um z.B. die entsprechende ID zu erhalten.
     */
    private String[] searchForRowInTargetDb(final String[] data, int dataHashCode) throws JPressoException {
        final String compStmnt = getDBCompareStmnt(data);
        if (debug) {
            log.debug("getDBCompareStmnt():" + compStmnt);
        }
        try {
            final Statement s = targetConn.createStatement();
            final ResultSet result = s.executeQuery(compStmnt);
            if (!result.next()) {
                // nix gefunden
                //log.debug("nix gefunden");
                result.close();
                s.close();
                return null;
            } else {
                //was gefunden
                final String[] ret = new String[data.length];
                for (int i = 0; i < ret.length;) {
                    ret[i] = result.getString(++i);
                }
                //Bevor jetzt die Zeile zurueckgegeben wird, wird sie noch in
                //foundInDbTable abgespeichert, damit sie spaeter schneller gefunden wird
                result.close();
                s.close();
                //Escaping the retrieved data
                String encChar;
                for (int i = 0; i < enclChars.length; ++i) {
                    encChar = enclChars[i];
                    if (encChar.length() == 1) {
                        ret[i] = escapeCharacter(ret[i], encChar.charAt(0));
                    }
                }
                foundInDbTable.add(ret);
                dbIndex.put(dataHashCode, foundInDbTable.size() - 1);
                return ret;
            }
        } catch (java.sql.SQLException sqlEx) {
            throw new JPressoException(sqlEx.toString() + " " + sqlEx.getSQLState());
        }
    }

    /** 
     * Liefert das SQL-Statement mit dem ueberprueft wird, ob ein Datensatz schon in der
     * Datenbank steht. Wird zum normalisieren verwendet.
     * 
     * Now compares null-values correctly with "is null" and without enclosing chars!
     * 
     * @param fields int[] das die Felder angibt, die zum Vergleich herangezogen werden
     * @param data alle Daten dieses Datensatzes in einem String[]
     * @return SQL-Statement mit dem ueberprueft wird, ob ein Datensatz schon in der
     * Datenbank steht
     *
     * @TODO: kleines Optimierungspotential: Query: SELECT nur auf die Attribute,
     *        die sp채ter noch gebraucht werden (= die referenziert werden).
     */
    private final String getDBCompareStmnt(final String[] data) {
        //Statement zum ueberpruefen im Zielsystem wird nun zusammengebaut
        final int range = compareFields.length;
        final StringBuilder testingStatementBuf = new StringBuilder(SELECT);
        for (int i = 0; i < data.length;) {
            testingStatementBuf.append(this.columnNames[i]);
            if (++i < data.length) {
                testingStatementBuf.append(KOMMA);
            }
        }

        testingStatementBuf.append(FROM).append(tableName).append(WHERE);

        String cur;
        String eChar;
        for (int i = 0; i < range;/* increased in body*/) {
            // Hier Fallunterscheidung ob mit enclosingChars oder nicht
            eChar = enclChars[compareFields[i]];
            if (eChar == null) {
                eChar = EMPTY_STRING;
            }
            cur = data[compareFields[i]];
            // Fallunterscheidung (=) oder (is null)
            if (cur != null) {
//                if ("'".equals(eChar)) {
//                    //Backslash Escaping for Strings in "where"-clause
//                    cur = escapeCharacter(cur, '\\');
//                }
                testingStatementBuf.append(this.columnNames[compareFields[i]]).append(EQUALS).append(eChar).append(cur).append(eChar);
            } else {
                testingStatementBuf.append(this.columnNames[compareFields[i]]).append(IS_NULL);
            }
            if (++i < range) {
                testingStatementBuf.append(AND);
            }
        }
        return testingStatementBuf.toString();
    }

    @Override
    public final int getRowCount() {
        if (memTable == null) {
            return 0;
        } else {
            return memTable.size();
        }
    }

    @Override
    public final String getValueAt(final int row, final int column) {
        return memTable.get(row)[column];
    }

    @Override
    public void clearAllCaches() {
        foundInDbTable.clear();
        tableIndex.clear();
        dbIndex.clear();
    }

    @Override
    public final void adjustCountersToActualValues() {
        if (memTable.size() > 0) {
            final String[] latestRow = memTable.get(memTable.size() - 1);
            for (int i = 0; i < getAutoIncFields().length; ++i) {
                counterValues[autoIncFields[i]] = Integer.parseInt(latestRow[getAutoIncFields()[i]]) + 1;
            }
        }
    }
}
