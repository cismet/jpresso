/***************************************************
*
* cismet GmbH, Saarbruecken, Germany
*
*              ... and it just works.
*
****************************************************/
/*
 * IntermedTableMemoryImpl.java
 *
 * Created on 17. September 2003, 13:16
 */
package de.cismet.jpresso.core.kernel;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

import java.util.List;
import java.util.Map;

import javax.swing.event.TableModelEvent;

import de.cismet.jpresso.core.exceptions.NoValuesException;
import de.cismet.jpresso.core.serviceprovider.exceptions.JPressoException;
import de.cismet.jpresso.core.utils.TypeSafeCollections;

/**
 * This class represents a RAM-based implementation of an IntermedTable.
 *
 * @author   srichter
 * @version  $Revision$, $Date$
 */
public final class IntermedTableMemoryImpl extends IntermedTable {

    //~ Instance fields --------------------------------------------------------

    /** Container der die Daten aufnimmt. */
    private final List<String[]> memTable;
    /** Container der Daten speichert die schon einmal in der Datenbank gefunden wurden. */
    // sprich: tatsaechlich schon in der datenbank drinstehen
    private final List<String[]> foundInDbTable;
    // indexes for faster normalization lookups
    private final Map<Integer, Integer> tableIndex;
    private final Map<Integer, Integer> dbIndex;
    //
    private final boolean normalize;

    //~ Constructors -----------------------------------------------------------

    /**
     * Creates a new instance of IntermedTableMemoryImpl.
     *
     * @param  tableName       Tabellenname der Zieltabelle
     * @param  targetFields    Spaletnnamen der Zieltabelle
     * @param  enclChars       Array der Zeichen die bei einem Vergleich oder Insert um den jeweiligen String kommen. In
     *                         der Regel ' oder Blank
     * @param  compareFields   DOCUMENT ME!
     * @param  targetConn      Connection zum Zielsystem
     * @param  autoIncFields   DOCUMENT ME!
     * @param  deleteOrphaned  DOCUMENT ME!
     */
    @SuppressWarnings("unchecked") // can not compromise
    public IntermedTableMemoryImpl(final String tableName,
            final String[] targetFields,
            final String[] enclChars,
            final int[] compareFields,
            final Connection targetConn,
            final int[] autoIncFields,
            final boolean deleteOrphaned) {
        super(targetFields, enclChars, compareFields, tableName, targetConn, autoIncFields, deleteOrphaned);
        this.targetConn = targetConn;
        memTable = TypeSafeCollections.newArrayList();
        foundInDbTable = TypeSafeCollections.newArrayList();
        tableIndex = TypeSafeCollections.newHashMap();
        dbIndex = TypeSafeCollections.newHashMap();
        if ((compareFields != null) && (compareFields.length > 0)) {
            normalize = true;
        } else {
            normalize = false;
        }
        setColumnNameToNumberMapping(targetFields);
        if (log.isDebugEnabled()) {
            log.debug("setColumnNameToNumberMapping(targetFields):" + this.columnNameToNumberMapping);
        }
    }

    //~ Methods ----------------------------------------------------------------

    @Override
    public void setValueAt(final Object aValue, final int row, final int column) {
        if ((row < getRowCount()) && (column < columnNames.length)) {
            if (aValue != null) {
                memTable.get(row)[column] = aValue.toString();
            } else {
                memTable.get(row)[column] = null;
            }
            fireTableChanged(new TableModelEvent(this, row, row, column));
        } else {
            log.error("Accessing not existing table element: (" + row + ", " + column + ")!");
        }
    }

    /**
     * Liefert den neuesten Wert in der angegebenen Spalte.
     *
     * @return  Wert der Zelle als String
     */
    @Override
    public String[] getNextAutogeneratedValues() {
        final String[] result = new String[getAutoIncFields().length];
        for (int i = 0; i < getAutoIncFields().length; ++i) {
            if (memTable.size() == 0) {
                result[i] = getNextValueFromDB(getAutoIncFields()[i]);
            } else {
                result[i] = String.valueOf(++counterValues[autoIncFields[i]]);
            }
        }
        return result;
    }

    // used in container
    /**
     * Fuegt der IntermedTableMemoryImpl eine neue Zeile an.
     *
     * @param  rowData  String[] der neuen Zeile
     */
    @Override
    public void addRow(final String[] rowData) {
        memTable.add(rowData);
        if (normalize) {
            tableIndex.put(generateMultiStringHashCode(rowData), memTable.size() - 1);
        }
    }

    /**
     * Fuellt die Hashtabel columnNameToNumberMapping.
     *
     * @param  columnNames  String[] der Spaltennamen
     */
    private void setColumnNameToNumberMapping(final String[] columnNames) {
        columnNameToNumberMapping.clear();
        for (int i = 0; i < columnNames.length; ++i) {
            columnNameToNumberMapping.put(columnNames[i], i);
        }
    }

    /**
     * ueberprueft ob der uebergebene Datensatz schon in der Datenstruktur vorkommt. Entscheidende Methode zur
     * Realisierung der Normalisierungsfunktionalitaet. Diese Methode untersucht nur die Hauptspeicherstruktur. Es
     * werden nur Spalten zum Vergleich herangezogen die in fields[] angegeben sind.
     *
     * @param   data        <B>komplette</B> Zeile die ueberprueft werden soll
     * @param   container   Gibt an in welchem Container gesucht wird
     * @param   startIndex  fields int[] indem die Spaltennummern angegeben werden die zum Vergleich herangezogen werden
     *
     * @return  Falls eine uebereinstimmung gefunden wurde wird die entsprechende Zeile zurueckgegeben, um z.B. die
     *          entsprechende ID zu erhalten.
     */
    private String[] searchForRow(final String[] data, final List<String[]> container, final int startIndex) {
        if (container == null) {
            return null;
        }
        // search in reverse order, as it is more likely to find a matching item
        // shortly inserted before - performance tuning
        for (int i = startIndex - 1; i < -1; --i) {
//        for (int i = 0; i < container[0].size(); ++i) {
            boolean newRow = false;
            String a;
            String b;
            for (final int j : compareFields) {
                a = data[j];
                b = container.get(i)[j];
                if (a != null) {
                    if (!a.equals(b)) {
                        newRow = true;
                        break;
                    }
                } else if (b != null) {
                    newRow = true;
                    break;
                }
            }
            if (!newRow) {
                // Alles klar eine ganze zeile hat uebereingestimmt
                return container.get(i);
            }
        }
        return null;
    }

    /**
     * Generates a hashcode for a row, according to the given comparefields.
     *
     * @param   input  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    private int generateMultiStringHashCode(final String[] input) {
        if (input == null) {
            return 0;
        }
        int result = 1;
        String element;
        for (int i = 0; i < compareFields.length; ++i) {
            element = input[compareFields[i]];
            int elementHash = 0;
            if (element != null) {
                elementHash = element.hashCode();
            }
            result = (31 * result) + elementHash;
        }
        return result;
    }

    /**
     * Test to see if two rows are equal with regards to their comparefields.
     *
     * @param   one  DOCUMENT ME!
     * @param   two  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    private boolean areRowsEqual(final String[] one, final String[] two) {
        String a;
        String b;
        if (one == two) {
            return true;
        } else if (one == null) {
            return false;
        }
        if (one.length != two.length) {
            return false;
        }
        for (final int j : compareFields) {
            a = one[j];
            b = two[j];
            if (a != null) {
                if (!a.equals(b)) {
                    return false;
                }
            } else if (b != null) {
                return false;
            }
        }
        return true;
    }

    /**
     * DOCUMENT ME!
     *
     * @param   index      DOCUMENT ME!
     * @param   requested  DOCUMENT ME!
     * @param   container  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    private String[] indexLookup(final int index, final String[] requested, final List<String[]> container) {
        final String[] ret = container.get(index);
        if (!areRowsEqual(requested, ret)) {
            return null;
        } else {
            return ret;
        }
    }

    /**
     * Ueberprueft ob der uebergebene Datensatz schon in der Datenstruktur vorkommt. Entscheidende Methode zur
     * Realisierung der Normalisierungsfunktionalitaet. Diese Methode untersucht nur die Hauptspeicherstruktur. Es
     * werden nur Spalten zum Vergleich herangezogen die in fields[] angegeben sind.
     *
     * @param   data            <B>komplette</B> Zeile die ueberprueft werden soll
     * @param   alsoInDatabase  ist dieses Flag auf true gesetzt, wird nicht nur der momentane Import- datenbestand fuer
     *                          einen Vergleich ueberprueft, sondern auch die echte Zieltabelle (Datenbank) ueberprueft.
     *
     * @return  Falls eine uebereinstimmung gefunden wurde wird die entsprechende Zeile zurueckgegeben, um z.B. die
     *          entsprechende ID zu erhalten.
     *
     *          <p>Genutzt vom IntermedTablesContainer.</p>
     */
    @Override
    public String[] searchForRow(final String[] data, final boolean alsoInDatabase) {
        // Datensatz im Hauptspeicher suchen. Zuerst den HashCode berechnen:
        final int dataHashCode = generateMultiStringHashCode(data);
        // Zuerst über den Index
        final Integer indexMem = tableIndex.get(dataHashCode);
        String[] ret = null;
        if (indexMem != null) {
            ret = indexLookup(indexMem, data, memTable);
        }
        if (ret == null) {
            // Fehlerschlag: ggf noch ueber den DB-Cache Index
            final Integer indexDB = dbIndex.get(dataHashCode);
            if (alsoInDatabase) {
                if (indexDB != null) {
                    ret = indexLookup(indexDB, data, foundInDbTable);
                }
            }
            if (ret == null) {
                // Sonst komplett in allen in den bereits eingetragenen Zeilen der Speichertabelle suchen,
                // wenn der Hashtest ergeben hat, dass die Zeile überhaupt dort sein KOENNTE (indexM != null)
                if (indexMem != null) {
                    // Wir durchsuchen den Speicher nur oberhalb von indexMem, da
                    // dort der letzte Wert liegt der auf den gleichen Wert wie
                    // unsere gesuchte Zeile hashed. (Garantiert duch Funktions-
                    // weise von addRow(final String[] rowData))
                    ret = searchForRow(data, memTable, indexMem);
                }
                // wir muessen wenn alsoInDatabase == true ist auch in der Datenbank nachsehen
                if ((ret == null) && alsoInDatabase) {
                    // zuerst in der Merkertabelle für alles was schon in der Datenbank nachgeschaut wurde
                    // Wurde der Datensatz schon in der Datenbank gefunden? (Gibt nur Sinn wenn die Zeile
                    // schon gehashed wurde)
                    if (indexDB != null) {
                        // auch hier gilt wie bei indexMem: Suche beginnt
                        // oberhalb unseres gehashten Index
                        ret = searchForRow(data, foundInDbTable, indexDB);
                    }
                    if (ret == null) {
                        // und zuletzt noch in der datenbank nachschauen
                        try {
                            ret = searchForRowInTargetDb(data, dataHashCode);
                        } catch (JPressoException ex) {
                            // erst mal nix machen
                            final String msg = "Normalizing error on DB: " + ex.getMessage()
                                        + ".\n Possible missing quotes on String/Date\nor waste quotes on non-String/Date value?";
                            log.warn(msg);
                        }
                    }
                }
            }
        }
        return ret;
    }

    /**
     * Ueberprueft ob der uebergebene Datensatz schon in der Datenbank vorkommt. Entscheidende Methode zur Realisierung
     * der Normalisierungsfunktionalitaet. Diese Methode untersucht nur die Datenbank Es werden nur Spalten zum
     * Vergleich herangezogen die in fields[] angegeben sind.
     *
     * @param   data          <B>komplette</B> Zeile die ueberprueft werden soll
     * @param   dataHashCode  fields int[] indem die Spaltennummern angegeben werden die zum Vergleich herangezogen
     *                        werden
     *
     * @return  Falls eine Uebereinstimmung gefunden wurde wird die entsprechende Zeile zurueckgegeben, um z.B. die
     *          entsprechende ID zu erhalten.
     *
     * @throws  JPressoException  wird geworfen, wenn ein Fehler auftritt (DB, ...)
     */
    private String[] searchForRowInTargetDb(final String[] data, final int dataHashCode) throws JPressoException {
        final String compStmnt = getDBCompareStmnt(data);
        if (debug) {
            if (log.isDebugEnabled()) {
                log.debug("getDBCompareStmnt():" + compStmnt);
            }
        }
        try {
            final Statement s = targetConn.createStatement();
            final ResultSet result = s.executeQuery(compStmnt);
            if (!result.next()) {
                // nix gefunden
                // log.debug("nix gefunden");
                result.close();
                s.close();
                return null;
            } else {
                // was gefunden
                final String[] ret = new String[data.length];
                for (int i = 0; i < ret.length;) {
                    ret[i] = result.getString(++i);
                }
                // Bevor jetzt die Zeile zurueckgegeben wird, wird sie noch in
                // foundInDbTable abgespeichert, damit sie spaeter schneller gefunden wird
                result.close();
                s.close();
                // Escaping the retrieved data
                String encChar;
                for (int i = 0; i < enclChars.length; ++i) {
                    encChar = enclChars[i];
                    if (encChar.length() == 1) {
                        ret[i] = escapeCharacter(ret[i], encChar.charAt(0));
                    }
                }
                foundInDbTable.add(ret);
                dbIndex.put(dataHashCode, foundInDbTable.size() - 1);
                return ret;
            }
        } catch (java.sql.SQLException sqlEx) {
            throw new JPressoException(sqlEx.toString() + " " + sqlEx.getSQLState());
        }
    }

    /**
     * Liefert das SQL-Statement mit dem ueberprueft wird, ob ein Datensatz schon in der Datenbank steht. Wird zum
     * normalisieren verwendet.
     *
     * <p>Now compares null-values correctly with "is null" and without enclosing chars!</p>
     *
     * @param   data  alle Daten dieses Datensatzes in einem String[]
     *
     * @return  SQL-Statement mit dem ueberprueft wird, ob ein Datensatz schon in der Datenbank steht
     *
     * @TODO:   kleines Optimierungspotential: Query: SELECT nur auf die Attribute, die später noch gebraucht werden (=
     *          die referenziert werden).
     */
    private String getDBCompareStmnt(final String[] data) {
        // Statement zum ueberpruefen im Zielsystem wird nun zusammengebaut
        final int range = compareFields.length;
        final StringBuilder testingStatementBuf = new StringBuilder(SELECT);
        for (int i = 0; i < data.length;) {
            testingStatementBuf.append(this.columnNames[i]);
            if (++i < data.length) {
                testingStatementBuf.append(KOMMA);
            }
        }

        testingStatementBuf.append(FROM).append(tableName).append(WHERE);

        String cur;
        String eChar;
        for (int i = 0; i < range; /* increased in body*/) {
            // Hier Fallunterscheidung ob mit enclosingChars oder nicht
            eChar = enclChars[compareFields[i]];
            if (eChar == null) {
                eChar = EMPTY_STRING;
            }
            cur = data[compareFields[i]];
            // Fallunterscheidung (=) oder (is null)
            if (cur != null) {
//                if ("'".equals(eChar)) {
//                    //Backslash Escaping for Strings in "where"-clause
//                    cur = escapeCharacter(cur, '\\');
//                }
                testingStatementBuf.append(this.columnNames[compareFields[i]])
                        .append(EQUALS)
                        .append(eChar)
                        .append(cur)
                        .append(eChar);
            } else {
                testingStatementBuf.append(this.columnNames[compareFields[i]]).append(IS_NULL);
            }
            if (++i < range) {
                testingStatementBuf.append(AND);
            }
        }
        return testingStatementBuf.toString();
    }

    @Override
    public int getRowCount() {
        if (memTable == null) {
            return 0;
        } else {
            return memTable.size();
        }
    }

    @Override
    public String getValueAt(final int row, final int column) {
        return memTable.get(row)[column];
    }

    @Override
    public void clearAllCaches() {
        foundInDbTable.clear();
        tableIndex.clear();
        dbIndex.clear();
    }

    @Override
    public void adjustCountersToActualValues() {
        if (memTable.size() > 0) {
            final String[] latestRow = memTable.get(memTable.size() - 1);
            for (int i = 0; i < getAutoIncFields().length; ++i) {
                counterValues[autoIncFields[i]] = Integer.parseInt(latestRow[getAutoIncFields()[i]]) + 1;
            }
        }
    }
}
