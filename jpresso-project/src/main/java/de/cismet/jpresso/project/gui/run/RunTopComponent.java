/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package de.cismet.jpresso.project.gui.run;

import de.cismet.jpresso.core.data.ImportRules;
import de.cismet.jpresso.core.data.Mapping;
import de.cismet.jpresso.core.data.Options;
import de.cismet.jpresso.core.data.Reference;
import de.cismet.jpresso.project.gui.editors.ConnectionEditor;
import de.cismet.jpresso.project.gui.editors.MappingEditor;
import de.cismet.jpresso.project.gui.editors.OptionsEditor;
import de.cismet.jpresso.project.gui.editors.ReferenceEditor;
import de.cismet.jpresso.project.gui.output.OutputFinalizer;
import de.cismet.jpresso.project.gui.output.OutputInitializing;
import de.cismet.jpresso.project.gui.output.OutputIntermedTable;
import de.cismet.jpresso.project.gui.editors.QueryEditor;
import de.cismet.jpresso.project.gui.AbstractJPTopComponent;
import de.cismet.jpresso.project.gui.ProgressHandler;
import de.cismet.jpresso.project.gui.dnd.JPDataFlavors;
import de.cismet.jpresso.project.serviceprovider.CodeFunctionProvider;
import de.cismet.jpresso.project.gui.output.OutputTabbedPaneFactory;
import de.cismet.jpresso.core.serviceprovider.exceptions.DynamicCompilingException;
import de.cismet.jpresso.core.data.DatabaseConnection;
import de.cismet.jpresso.core.data.Query;
import de.cismet.jpresso.core.serviceprovider.ClassResourceProvider;
import de.cismet.jpresso.core.serviceprovider.ExtractAndTransformController;
import de.cismet.jpresso.core.serviceprovider.ControllerFactory;
import de.cismet.jpresso.core.serviceprovider.FinalizerController;
import de.cismet.jpresso.core.serviceprovider.FinalizerCreator;
import de.cismet.jpresso.core.serviceprovider.exceptions.InitializingException;
import de.cismet.jpresso.core.utils.TypeSafeCollections;
import de.cismet.jpresso.project.filetypes.connection.ConnectionDataNode;
import de.cismet.jpresso.project.filetypes.connection.ConnectionDataObject;
import de.cismet.jpresso.project.filetypes.cookies.ConnectionListModelProvider;
import de.cismet.jpresso.project.filetypes.cookies.QueryListModelProvider;
import de.cismet.jpresso.project.filetypes.query.QueryDataNode;
import de.cismet.jpresso.project.filetypes.query.QueryDataObject;
import de.cismet.jpresso.project.filetypes.run.RunDataObject;
import de.cismet.jpresso.project.serviceprovider.ExecutorProvider;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Point;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.DnDConstants;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.beans.PropertyChangeEvent;
import java.io.Serializable;
import java.text.DateFormat;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingWorker;
import javax.swing.TransferHandler;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.TableModel;
import org.openide.DialogDisplayer;
import org.openide.NotifyDescriptor;
import org.openide.cookies.OpenCookie;
import org.openide.explorer.view.NodeListModel;
import org.openide.loaders.DataNode;
import org.openide.util.Cancellable;
import org.openide.util.NbBundle;

/**
 * Top component which visualizes a run.
 */
public final class RunTopComponent extends AbstractJPTopComponent<RunDataObject> implements TableModelListener, ItemListener, ListDataListener {

    private static final String PREFERRED_ID = "RunTopComponent";
    private ConnectionEditor dce;
    private QueryEditor qe;
    private MappingEditor mappings;
    private ReferenceEditor references;
    private OptionsEditor options;
    private FinalizerCreator finCreator;
    private ConnectionDataObject currentConnection;
    private QueryDataObject currentQuery;

    // <editor-fold defaultstate="collapsed" desc="Constructors">
    public RunTopComponent(RunDataObject data) {
        super(data);
        setListenerActive(false);
        initComponents();
        finCreator = null;
//        setDisplayName(data.getPrimaryFile().getNameExt());
        myInit();
        data.setModified(false);
        setListenerActive(true);
    }

// </editor-fold>
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content outFin this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jPanel7 = new javax.swing.JPanel() {
            //    protected void paintComponent(Graphics g) {
                //        super.paintComponent(g);
                //        Graphics2D g2 = (Graphics2D) g;
                //        Point2D center = new Point2D.Double(getWidth()/2, getHeight()/2);
                //        float radius = getWidth()/1.4f;
                //        Point2D irgendwas = new Point2D.Double(45.0, 25.0);
                //        float[] dist = {0.0f, 0.5f};
                //        Color c1 = new Color(1.0f, 1.0f, 1.0f, 1.0f);
                //        Color c2 = new Color(0.0f, 0.0f, 0.0f, 0.0f);
                //        Color[] colors = {c1, c2};
                //        RadialGradientPaint rgp = new RadialGradientPaint(center, radius, irgendwas, dist, colors, RadialGradientPaint.CycleMethod.NO_CYCLE);
                //        g2.setPaint(rgp);
                //        g2.fillOval(0, 0, getWidth(), getHeight());
                //    }
        }
        ;
        jSplitPane2 = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel12 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jPanel13 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        jTabbedPane2 = OutputTabbedPaneFactory.createOutputTabbedPane();
        jToolBar1 = new javax.swing.JToolBar();
        jButton7 = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JToolBar.Separator();
        jLabel1 = new javax.swing.JLabel();
        jPanel6 = new javax.swing.JPanel();
        jComboBox1 = new javax.swing.JComboBox();
        jButton8 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JToolBar.Separator();
        jLabel2 = new javax.swing.JLabel();
        jPanel10 = new javax.swing.JPanel();
        jComboBox2 = new javax.swing.JComboBox();
        jButton9 = new javax.swing.JButton();
        jButton6 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        lblStatus = new javax.swing.JLabel();

        setLayout(new java.awt.BorderLayout());

        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        jPanel1.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 1, 0));
        jPanel1.setLayout(new java.awt.BorderLayout());

        jPanel7.setLayout(new java.awt.BorderLayout());

        jSplitPane2.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        jPanel12.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jPanel12MouseClicked(evt);
            }
        });
        jPanel12.setLayout(new java.awt.BorderLayout());
        jScrollPane1.setViewportView(jPanel12);

        jSplitPane2.setBottomComponent(jScrollPane1);

        jPanel13.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jPanel13MouseClicked(evt);
            }
        });
        jPanel13.setLayout(new java.awt.BorderLayout());
        jScrollPane2.setViewportView(jPanel13);

        jSplitPane2.setLeftComponent(jScrollPane2);

        jPanel7.add(jSplitPane2, java.awt.BorderLayout.CENTER);

        jPanel1.add(jPanel7, java.awt.BorderLayout.CENTER);

        jTabbedPane1.addTab("Connection", jPanel1);

        jPanel2.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));
        jPanel2.setLayout(new java.awt.BorderLayout());
        jTabbedPane1.addTab("Mappings", jPanel2);

        jPanel3.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));
        jPanel3.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                jPanel3ComponentShown(evt);
            }
        });
        jPanel3.setLayout(new java.awt.BorderLayout());
        jTabbedPane1.addTab("References", jPanel3);

        jPanel4.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                jPanel4ComponentShown(evt);
            }
        });
        jPanel4.setLayout(new java.awt.BorderLayout());
        jTabbedPane1.addTab("Options", jPanel4);

        jSplitPane1.setLeftComponent(jTabbedPane1);

        jPanel5.setLayout(new java.awt.BorderLayout());
        jPanel5.add(jTabbedPane2, java.awt.BorderLayout.CENTER);

        jSplitPane1.setRightComponent(jPanel5);

        add(jSplitPane1, java.awt.BorderLayout.CENTER);

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jButton7.setToolTipText("Check Syntax And Settings");
        jButton7.setFocusable(false);
        jButton7.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton7.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton7ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton7);

        jButton1.setToolTipText("Fill Intermed Table");
        jButton1.setFocusable(false);
        jButton1.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton1.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton1);

        jButton2.setToolTipText("Write Intermed Table to Target");
        jButton2.setEnabled(false);
        jButton2.setFocusable(false);
        jButton2.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton2.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton2);

        jButton3.setToolTipText("Fill Intermed Table And Write To Target");
        jButton3.setFocusable(false);
        jButton3.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton3.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton3);

        jButton4.setToolTipText("Clear Intermed Table");
        jButton4.setEnabled(false);
        jButton4.setFocusable(false);
        jButton4.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton4.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton4);
        jToolBar1.add(jSeparator1);

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, "  Source Query:"); // NOI18N
        jToolBar1.add(jLabel1);

        jPanel6.setMaximumSize(new java.awt.Dimension(210, 30));

        jComboBox1.setMinimumSize(new java.awt.Dimension(200, 20));
        jComboBox1.setPreferredSize(new java.awt.Dimension(200, 20));
        jComboBox1.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                jComboBox1ItemStateChanged(evt);
            }
        });
        jPanel6.add(jComboBox1);

        jToolBar1.add(jPanel6);

        jButton8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/jpresso/project/res/edit.png"))); // NOI18N
        jButton8.setToolTipText("Edit");
        jButton8.setFocusable(false);
        jButton8.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton8.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton8ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton8);

        jButton5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/jpresso/project/res/search.png"))); // NOI18N
        jButton5.setToolTipText("Show Query Result");
        jButton5.setFocusable(false);
        jButton5.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton5.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton5);
        jToolBar1.add(jSeparator2);

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, "  Target Connection: "); // NOI18N
        jToolBar1.add(jLabel2);

        jPanel10.setMaximumSize(new java.awt.Dimension(210, 30));

        jComboBox2.setMinimumSize(new java.awt.Dimension(200, 20));
        jComboBox2.setPreferredSize(new java.awt.Dimension(200, 20));
        jComboBox2.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                jComboBox2ItemStateChanged(evt);
            }
        });
        jPanel10.add(jComboBox2);

        jToolBar1.add(jPanel10);

        jButton9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/jpresso/project/res/edit.png"))); // NOI18N
        jButton9.setToolTipText("Edit");
        jButton9.setFocusable(false);
        jButton9.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton9.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton9.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton9ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton9);

        jButton6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/jpresso/project/res/search.png"))); // NOI18N
        jButton6.setToolTipText("Show Database Tables");
        jButton6.setFocusable(false);
        jButton6.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton6.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton6);

        jLabel3.setMaximumSize(new java.awt.Dimension(9999, 50));
        jLabel3.setMinimumSize(new java.awt.Dimension(100, 0));
        jLabel3.setPreferredSize(new java.awt.Dimension(100, 0));
        jToolBar1.add(jLabel3);

        lblStatus.setToolTipText("Autocomplete fields disabled. Execute a source query to enable!");
        lblStatus.setEnabled(false);
        jToolBar1.add(lblStatus);

        add(jToolBar1, java.awt.BorderLayout.NORTH);
    }// </editor-fold>//GEN-END:initComponents
//TODO Button disablen und enablen verbessern
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed

        references.stopEditing();
        mappings.stopEditing();
        mappings.clearErrors();
        clearIntermedTable();
        disableAllButtons();
        startWait("Processing Query...");
        final FillWorker fill = new FillWorker();
        ExecutorProvider.execute(fill);
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jPanel4ComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_jPanel4ComponentShown
        setListenerActive(false);
        final Options o = options.getOptionsContent();
        options.setTables(getAllUsedTargetTables(), getAllUsedTargetTablesWithPath());
        options.setContent(o);
        setListenerActive(true);//GEN-LAST:event_jPanel4ComponentShown
    }

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        if (this.finCreator != null) {
            this.runFinalize();
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        references.stopEditing();
        mappings.stopEditing();
        mappings.clearErrors();
        references.clearErrors();
        clearIntermedTable();
        disableAllButtons();
        startWait("Processing Query...");
        final FinalizerWorker fw = new FinalizerWorker();
        ExecutorProvider.execute(fw);
//        fw.execute();
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        clearIntermedTable();
    }//GEN-LAST:event_jButton4ActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        qe.checkSourceConnection();
    }//GEN-LAST:event_jButton5ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        dce.checkTargetConnection(false);
    }//GEN-LAST:event_jButton6ActionPerformed

    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton7ActionPerformed
        references.stopEditing();
        mappings.stopEditing();
        mappings.clearErrors();
        references.clearErrors();
        disableAllButtons();
        startWait("Checking Import Definiton...");
        final CreateWorker cw = new CreateWorker(false);
        ExecutorProvider.execute(cw);
//        cw.execute();
    }//GEN-LAST:event_jButton7ActionPerformed

    private void jButton8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton8ActionPerformed
        openQueryEditor();
    }//GEN-LAST:event_jButton8ActionPerformed

    private void jButton9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton9ActionPerformed
        openConnectionEditor();
    }//GEN-LAST:event_jButton9ActionPerformed

    private void jComboBox1ItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_jComboBox1ItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            setAutocompleteStatus(false);
            if (isListenerActive()) {
                getData().setModified(true);
            }
            final QueryDataObject qc = getDataFromComboBox(jComboBox1, QueryDataObject.class);
            setCurrentQuery(qc);
            Query q = null;
            if (getCurrentQuery() != null && getCurrentQuery().getData() != null) {
                q = getCurrentQuery().getData();
            } else {
                q = new Query();
            }
            //@clearing intermed
            clearIntermedTable();
            qe.setContent(q);
        }
    }//GEN-LAST:event_jComboBox1ItemStateChanged

    private void jComboBox2ItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_jComboBox2ItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            if (isListenerActive()) {
                getData().setModified(true);
            }
            final ConnectionDataObject cc = getDataFromComboBox(jComboBox2, ConnectionDataObject.class);
            setCurrentConnection(cc);
            //@clearing intermed
            clearIntermedTable();
            DatabaseConnection dc = null;
            if (getCurrentConnection() != null && getCurrentConnection().getData() != null) {
                dc = getCurrentConnection().getData();
            } else {
                dc = new DatabaseConnection();
            }
            dce.setContent(dc);
        }
    }//GEN-LAST:event_jComboBox2ItemStateChanged

private void jPanel3ComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_jPanel3ComponentShown
    //supply reference editor with mappings for autocomplete!
    references.createReferenceAutoCompleteHash(mappings.getContent());
}//GEN-LAST:event_jPanel3ComponentShown

private void jPanel12MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel12MouseClicked
    if (evt.isControlDown()) {
        openConnectionEditor();
    }
}//GEN-LAST:event_jPanel12MouseClicked

private void jPanel13MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel13MouseClicked
    if (evt.isControlDown()) {
        openQueryEditor();
    }
}//GEN-LAST:event_jPanel13MouseClicked

    private void openConnectionEditor() {
        if (getCurrentConnection() != null) {
            final OpenCookie oc = getCurrentConnection().getCookie(OpenCookie.class);
            if (oc != null) {
                oc.open();
            }
        } else {
            NotifyDescriptor msg = new NotifyDescriptor.Message("Can not edit: No Connection selected!", NotifyDescriptor.PLAIN_MESSAGE);
            DialogDisplayer.getDefault().notify(msg);
            //TODO fragen ob neue connection erzeugt werden soll
        }
    }

    private void openQueryEditor() {
        if (getCurrentQuery() != null) {
            final OpenCookie oc = getCurrentQuery().getCookie(OpenCookie.class);
            if (oc != null) {
                oc.open();
            }
        } else {
            final NotifyDescriptor msg = new NotifyDescriptor.Message("Can not edit: No Query selected!", NotifyDescriptor.PLAIN_MESSAGE);
            DialogDisplayer.getDefault().notify(msg);
            //TODO fragen ob neue query erzeugt werden soll
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButton7;
    private javax.swing.JButton jButton8;
    private javax.swing.JButton jButton9;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JComboBox jComboBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel12;
    private javax.swing.JPanel jPanel13;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JToolBar.Separator jSeparator1;
    private javax.swing.JToolBar.Separator jSeparator2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JSplitPane jSplitPane2;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTabbedPane jTabbedPane2;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JLabel lblStatus;
    // End of variables declaration//GEN-END:variables

    // <editor-fold defaultstate="collapsed" desc="Superclass overrides and implements">
    @Override
    public void owningProjectChanged() {
        setListenerActive(false);
        qe.setContent(new Query());
        dce.setContent(new DatabaseConnection());
        initComboBoxes(getData());
        setListenerActive(true);
    }

    public boolean updateDataObject() {
        RunDataObject data = getData();
        if (data != null) {
            if (data != null && data.getData() != null) {
                data.getData().setMappings(mappings.getContent());
                data.getData().setReferences(references.getContent());
                data.getData().setOptions(options.getOptionsContent());
                data.getData().setRuntimeProperties(options.getRuntimePropsContent());

                ConnectionDataObject cCookie = getCurrentConnection();
                if (cCookie != null && cCookie.getPrimaryFile() != null) {
                    data.getData().setTargetConnection(cCookie.getPrimaryFile().getNameExt());
                } else {
                    data.getData().setTargetConnection("");
                }
                QueryDataObject qCookie = getCurrentQuery();
                if (qCookie != null && qCookie.getPrimaryFile() != null) {
                    data.getData().setSourceQuery(qCookie.getPrimaryFile().getNameExt());
                } else {
                    data.getData().setSourceQuery("");
                }

            }
        } else {
            log.error("Can not save: DataObject not existent!");
            return false;
        }
        return true;
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        if (finCreator != null) {
            finCreator.close();
        }
    }

    @Override
    protected void removeAllListenerOnClosed() {
//        jComboBox1.getModel().removeListDataListener(this);
//        jComboBox2.getModel().removeListDataListener(this);
//        if (currentConnection != null) {
//            currentConnection.removeConnectionDataListener(this);
//        }
//        if (currentQuery != null) {
//            currentQuery.removeQueryDataListener(this);
//        }
//        docTracker.destroy();
    }

    @Override
    public void componentClosed() {
        super.componentClosed();
        if (finCreator != null) {
            finCreator.close();
            finCreator = null;
            setButtonsEmpty();
        }
        jTabbedPane2.removeAll();
//        if (getData() != null) {
//            getData().setTopComponent(null);
//        }
        //dispose??
    }

    /** replaces this in object stream */
    @Override
    public Object writeReplace() {
        return new ResolvableHelper();
    }

    @Override
    protected String preferredID() {
        return PREFERRED_ID;
    }

    @Override
    public void addOutput(final JPanel out) {
        final Calendar now = Calendar.getInstance();
        final DateFormat format = DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.getDefault());
        jTabbedPane2.addTab(out.getName() + " @ " + format.format(now.getTime()) + "    ", out);
        jTabbedPane2.setSelectedIndex(jTabbedPane2.getTabCount() - 1);

        if (!isOpened()) {
            RunTopComponent.this.open();
        }
        RunTopComponent.this.requestActive();
        RunTopComponent.this.requestFocusInWindow(true);

    }

    @Override
    protected void componentShowing() {
        super.componentShowing();
        //TODO you can not rely on this...do better
        mappings.prepareAutoComplete(null);
    }

// </editor-fold>    
    // <editor-fold defaultstate="collapsed" desc="Getter & Setter">
    public ConnectionDataObject getCurrentConnection() {
        return currentConnection;
    }

    /**
     * 
     * @param currentConnection
     */
    private void setCurrentConnection(ConnectionDataObject currentConnection) {
        if (currentConnection == this.currentConnection) {
            return;
        }
        if (this.currentConnection != null) {
            this.currentConnection.removePropertyChangeListener(this);
        }
        if (currentConnection != null) {
            currentConnection.addPropertyChangeListener(this);
        }
        this.currentConnection = currentConnection;
    }

    public QueryDataObject getCurrentQuery() {
        return currentQuery;
    }

    /**
     * 
     * @param currentQuery
     */
    private void setCurrentQuery(QueryDataObject currentQuery) {
        if (currentQuery == this.currentQuery) {
            return;
        }
        if (this.currentQuery != null) {
            this.currentQuery.removePropertyChangeListener(this);
        }
        if (currentQuery != null) {
            currentQuery.addPropertyChangeListener(this);
        }
        this.currentQuery = currentQuery;
    }

    public void setSourceFields(final String[] s) {
        this.mappings.prepareAutoComplete(s);
    }

    public void addMappings(final List<Mapping> maps) {
        mappings.addMappings(maps);
    }

    public void addRelations(final List<Reference> rel) {
        references.addReference(rel);
    }

// </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Own private Methods">
    private ImportRules getImportRules() {
        final ImportRules impRules = new ImportRules();
        impRules.setFileName(getData().getPrimaryFile().getName());
        impRules.setSourceQuery(qe.getContent());
        impRules.setTargetConnection(dce.getTargetConContent());
        impRules.setMappings(mappings.getContent());
        if (references.getContent().size() != 0) {
            impRules.setReferences(references.getContent());
        }
//        if (options.getOptionsContent().getNormalize().size() != 0) {
        impRules.setOptions(options.getOptionsContent());
//        }
        impRules.setRuntimeProperties(options.getRuntimePropsContent());
        return impRules;
    }

    private void clearIntermedTable() {
        final FinalizerCreator tmp = finCreator;
        if (tmp != null) {
            tmp.close();
            finCreator = null;
            log.info("IntermedTable cleared.");
            //System.gc();
        }
        setButtonsEmpty();
    }

    /**
     * @return All TargetTables used in the Mapping to show in Options options.
     */
    private String[] getAllUsedTargetTables() {
        final List<Mapping> m = mappings.getContent();
        final HashSet<String> hs = TypeSafeCollections.newHashSet();
//        final List<Reference> r = references.getContent();
        for (final Mapping mapping : m) {
            hs.add(mapping.getTargetTable());
        }
//brauchen wir doch nicht? wenn eine tabelle NUR in den relationen eraehnt wird, wird nicht reingeschrieben, also was bitte normalisieren?
//        for (Reference relation : r) {
//            hs.add(relation.getDetailTable());
//            hs.add(relation.getMasterTable());
//        }


        final String[] ret = new String[hs.size()];
        int i = 0;
        Iterator<String> it = hs.iterator();
        while (it.hasNext()) {
            ret[i++] = it.next();
        }
        return ret;
    }

    /**
     * @return All TargetTables used in the Mapping to show in Options options.
     */
    private String[] getAllUsedTargetTablesWithPath() {
        final List<Mapping> m = mappings.getContent();
        final HashSet<String> hs = TypeSafeCollections.newHashSet();
        for (final Mapping mapping : m) {
            if (mapping.getPath() == null || mapping.getPath().length() < 1) {
                hs.add(mapping.getTargetTable());
            } else {
                hs.add(mapping.getTargetTable() + "[" + mapping.getPath() + "]");
            }
        }

        final String[] ret = new String[hs.size()];
        int i = 0;
        Iterator<String> it = hs.iterator();
        while (it.hasNext()) {
            ret[i++] = it.next();
        }
        return ret;
    }

    private void runFinalize() {
        if (finCreator == null) {
            return;
        }
        disableAllButtons();
//        startWait("");
        FinalizerWorker finalizerWorker = new FinalizerWorker();
        ExecutorProvider.execute(finalizerWorker);
//        finalizerWorker.execute();
    }

    public void setAutocompleteStatus(boolean status) {
        lblStatus.setEnabled(status);
        if (status) {
            lblStatus.setToolTipText("Autocomplete fields enabled");
        }
    }

    private void disableAllButtons() {
        jButton7.setEnabled(false);
        jButton1.setEnabled(false);
        jButton2.setEnabled(false);
        jButton3.setEnabled(false);
        jButton4.setEnabled(false);
    }

    private void setButtonsEmpty() {
        jButton7.setEnabled(true);
        jButton1.setEnabled(true);
        jButton2.setEnabled(false);
        jButton3.setEnabled(true);
        jButton4.setEnabled(false);
    }

    private void setButtonsFilled() {
        jButton7.setEnabled(true);
        jButton1.setEnabled(true);
        jButton2.setEnabled(true);
        jButton3.setEnabled(true);
        jButton4.setEnabled(true);
    }
// </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="myInit">

    private void myInit() {
        RunDataObject data = getData();
        this.dce = new ConnectionEditor();
        this.qe = new QueryEditor();
        this.mappings = new MappingEditor(data.getData().getMappings(), getProject().getLookup().lookup(CodeFunctionProvider.class));
        this.references = new ReferenceEditor(data.getData().getReferences());
        this.options = new OptionsEditor(this);
        //sets the available (table)names for normalization-checkboxes
        this.options.setTables(getAllUsedTargetTables(), getAllUsedTargetTablesWithPath());
        this.options.setContent(data.getData().getOptions());
        this.options.setContent(data.getData().getRuntimeProperties());
        //D&D stuff
        TransferHandler th = new TransferHandler() {

            @Override
            public int getSourceActions(JComponent c) {
                if (c == jSplitPane1) {
                    return DnDConstants.ACTION_COPY_OR_MOVE;
                }
                return DnDConstants.ACTION_NONE;
            }

            @Override
            public boolean canImport(final TransferSupport support) {
                final DataFlavor[] flavs = support.getDataFlavors();
                for (final DataFlavor df : flavs) {
                    if (df.equals(JPDataFlavors.NETBEANS_NODE_FLAVOR)) {
                        return true;
                    }
                }
                return false;
            }

            @Override
            public boolean importData(final TransferSupport e) {
                try {
                    final Transferable tr = e.getTransferable();
                    final DataFlavor[] flavors = tr.getTransferDataFlavors();
                    for (int i = 0; i < flavors.length; ++i) {
                        if (flavors[i].equals(JPDataFlavors.NETBEANS_NODE_FLAVOR)) {
                            final DataNode dn = (DataNode) tr.getTransferData(flavors[i]);
                            if (dn instanceof ConnectionDataNode) {
                                if (setComboBoxItemForNode(jComboBox2, dn)) {
                                    dce.checkTargetConnection(false);
                                }
                            } else if (dn instanceof QueryDataNode) {
                                if (setComboBoxItemForNode(jComboBox1, dn)) {
                                    qe.checkSourceConnection();
                                }
                            } else {
                                final OpenCookie oc = dn.getLookup().lookup(OpenCookie.class);
                                if (oc != null) {
                                    oc.open();
                                }
                            }
                        }
                    }
                } catch (Throwable t) {
                    log.debug("D&D problem!", t);
                }
                // Ein Problem ist aufgetreten
                return false;
            }
        };
        jSplitPane1.setTransferHandler(th);
        qe.setEditable(false);
        dce.setEditable(false);

        initComboBoxes(data);

        jPanel2.add(mappings, BorderLayout.CENTER);
        jPanel3.add(references, BorderLayout.CENTER);
        jPanel4.add(options, BorderLayout.CENTER);
        jPanel13.add(qe, BorderLayout.CENTER);
        jPanel12.add(dce, BorderLayout.CENTER);
        //jLabel1.setText(data.getData().getDriverClass());
        setName(NbBundle.getMessage(RunTopComponent.class, "CTL_RunTopComponent"));
        setToolTipText(NbBundle.getMessage(RunTopComponent.class, "HINT_RunTopComponent"));
//        setIcon(Utilities.loadImage(ICON_PATH, true));
        //listen for saveable changes
        mappings.setTableListener(this);
        references.setTableListener(this);
    }

    /**
     * TODO remove duplicated code! @ NullpointerException handling
     * 
     * @param data
     */
    private void initComboBoxes(final RunDataObject data) {
        final boolean listenerState = isListenerActive();
        setListenerActive(false);
        final QueryListModelProvider queryModelProv = getProject().getLookup().lookup(QueryListModelProvider.class);
        final ConnectionListModelProvider connectionModelProv = getProject().getLookup().lookup(ConnectionListModelProvider.class);
        if (queryModelProv != null && queryModelProv.getQueryListModel() != null) {
            NodeListModel model = queryModelProv.getQueryListModel();
            model.addListDataListener(this);
            jComboBox1.setModel(model);
        }
        if (connectionModelProv != null && connectionModelProv.getConnectionListModel() != null) {
            final NodeListModel model = connectionModelProv.getConnectionListModel();
            model.addListDataListener(this);
            jComboBox2.setModel(model);
        }
        try {
            if (!setComboBoxItemForFileName(jComboBox2, data.getData().getTargetConnection())) {
                final String message = ("Can not find this run's specified target connection " + data.getData().getTargetConnection() + ". No target selected.");
                log.error(message);
                NotifyDescriptor err = new NotifyDescriptor.Message(message);
                DialogDisplayer.getDefault().notify(err);
            }
        } catch (NullPointerException e) {
            final String message = ("Can not find this run's specified target connection. -> No target selected.");
            log.error(message);
            NotifyDescriptor err = new NotifyDescriptor.Exception(e, message);
            DialogDisplayer.getDefault().notify(err);
        }

        try {
            if (!setComboBoxItemForFileName(jComboBox1, data.getData().getSourceQuery())) {
                String message = ("Can not find this run's specified query " + data.getData().getSourceQuery() + ". -> No query selected.");
                log.error(message);
                NotifyDescriptor err = new NotifyDescriptor.Message(message);
                DialogDisplayer.getDefault().notify(err);
            }
        } catch (NullPointerException e) {
            final String message = ("Can not find this run's specified query. -> No query selected.");
            log.error(message, e);
            NotifyDescriptor err = new NotifyDescriptor.Exception(e, message);
            DialogDisplayer.getDefault().notify(err);
        }
        setListenerActive(listenerState);
    }

// </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Listener Methods">
    //----------------------------LISTENER METHODS-------------------------------
    public void intervalRemoved(ListDataEvent e) {
        if (jComboBox1.getSelectedIndex() < 0) {
            jComboBox1.setSelectedItem(null);
        }
        if (jComboBox2.getSelectedIndex() < 0) {
            jComboBox2.setSelectedItem(null);
        }
    }

    public void intervalAdded(ListDataEvent e) {
    }

    public void contentsChanged(ListDataEvent e) {
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        super.propertyChange(evt);
        if (evt.getPropertyName().equals(ConnectionDataObject.class.getCanonicalName())) {
            if (currentConnection != null && currentConnection.getData() != null) {
                dce.setContent(currentConnection.getData());
            } else {
                dce.setContent(new DatabaseConnection());
            }
        } else if (evt.getPropertyName().equals(QueryDataObject.class.getCanonicalName())) {
            if (currentQuery != null && currentQuery.getData() != null) {
                qe.setContent(currentQuery.getData());
                qe.setDatabaseConnection(currentQuery.getData().getConnection());
            } else {
                qe.setContent(new Query());
            }
        }
    }

    /**
     * called when mapping or relation table changes
     * 
     * @param e
     */
    public void tableChanged(TableModelEvent e) {
        if (isListenerActive()) {
            getData().setModified(true);
            //@clearing intermed
//            clearIntermedTable();
        }
    }

    public void itemStateChanged(ItemEvent e) {
        if (isListenerActive()) {
            getData().setModified(true);
            //@clearing intermed
//            clearIntermedTable();
        }
    }

// </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Swing Worker">
    //---------------------------SWING WORKER-----------------------------------
    /**
     * Worker that finalizes an Importer, using its (filled) IntermediateTables. (IMPORT STEP 3).
     */
    final class FinalizerWorker extends SwingWorker<Long, Void> implements Cancellable {

        public FinalizerWorker() {
            this.internalFinCreator = finCreator;
        }
        private OutputFinalizer outF;
        private String logs = "";
        private FinalizerCreator internalFinCreator;
        private FinalizerController internalFinController;

        @Override
        protected Long doInBackground() throws Exception {
            long errorCount = 0L;
            if (internalFinCreator == null) {
                FillWorker fill = new FillWorker(false);
                ExecutorProvider.execute(fill);
                //blocks and therefore always creates a "happens before"-relation between Fillworker and FinalizerWorker
                internalFinCreator = fill.get();
            }
            internalFinController = internalFinCreator.createFinalizer(options.getRuntimePropsContent(), new ProgressHandler(this));
            publish();
            errorCount = internalFinController.finalise();
            logs = internalFinController.getLogs();
//            //enable GC for large Objects
//            internalController = null;
            return errorCount;
        }

        @Override
        protected void process(final List<Void> chunks) {
            if (outF == null) {
                this.outF = new OutputFinalizer(internalFinController.getFinalizerOutputTable());
                addOutput(outF);
            }
        }

        @Override
        protected void done() {
            final OutputFinalizer outFin = this.outF;
            try {
                final Long errorCounter = get();
//                outFin = this.outF;
                if (outFin == null) {
                    process(null);
                } else {
                    outFin.setLog(logs);
                    if (!internalFinController.isCanceled()) {
                        Color c;
                        if (errorCounter == 0) {
                            c = Color.GREEN;
                        } else {
                            c = Color.ORANGE;
                        }
                        outFin.done("Import done. (" + errorCounter.toString() + " Errors)", c);

                        JOptionPane.showMessageDialog(RunTopComponent.this, "Import done. (" + errorCounter.toString() + " Errors)", "", JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        outFin.done("Import canceled. (" + errorCounter.toString() + " Errors)", Color.ORANGE);
                        JOptionPane.showMessageDialog(RunTopComponent.this, "Import canceled.", "", JOptionPane.INFORMATION_MESSAGE);
                    }
                }
            } catch (InterruptedException ex) {
                log.debug("Interrupted Exception", ex);
            } catch (ExecutionException ex) {
                final Throwable t = ex.getCause();
                //if this exception is from this doInBackground()...
                if (!(t instanceof ExecutionException)) {
                    if (outFin != null) {
                        outFin.done("Finalizing Error. Stopped!", Color.RED);
                    }
                    JOptionPane.showMessageDialog(RunTopComponent.this, "Finalizing Error.\n(" + t.toString() + ")", "Error", JOptionPane.ERROR_MESSAGE);
                    log.error("Finalizing Error.", t);
                }
            } catch (CancellationException ex) {
                internalFinController.cancel();
                if (outFin != null) {
                    outFin.done("Import canceled.", Color.ORANGE);
                }
                JOptionPane.showMessageDialog(RunTopComponent.this, "Import canceled.", "", JOptionPane.INFORMATION_MESSAGE);
            } finally {
                stopWait();
                if (internalFinCreator != null) {
                    setButtonsFilled();
                } else {
                    setButtonsEmpty();
                }
            }
        }

        public boolean cancel() {
            final FinalizerController toCancel = internalFinController;
            if (toCancel != null) {
                toCancel.cancel();
            }
            return true;
        }
    }

    /**
     * Worker that fills an Importer's Intermediate Table (IMPORT STEP 2).
     */
    final class FillWorker extends SwingWorker<FinalizerCreator, Void> implements Cancellable {

        public FillWorker() {
            this(true);
        }

        public FillWorker(final boolean lastInChain) {
            this.internalController = null;
            //is this the last worker in a chain outFin workers?
            this.lastInChain = lastInChain;
        }
        private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
        private ExtractAndTransformController internalController;
        private final boolean lastInChain;

        @Override
        protected FinalizerCreator doInBackground() throws Exception {
            final CreateWorker cw = new CreateWorker(true, false);
            ExecutorProvider.execute(cw);
            //blocks and therefore always creates a "happens before"-relation between CreateWorker and FillWorker
            internalController = cw.get();
            return internalController.runImport(new ProgressHandler(this));

        }

        @Override
        protected void done() {
            FinalizerCreator res = null;
            try {
                res = get();
                if (res != null) {
                    finCreator = res;
                    final Collection<? extends TableModel> tModels = res.getIntermedTableModels();
                    for (final TableModel tab : tModels) {
                        final String[] encChars = res.getEnclosingCharacters(tab);
                        addOutput(new OutputIntermedTable(tab, encChars));
                    }
                }
            } catch (InterruptedException ex) {
                log.debug("InterruptedException", ex);
            } catch (ExecutionException ex) {
                final Throwable e = ex.getCause();
                if (e instanceof CancellationException) {
                    final String msg = "Import canceled by User";
                    JOptionPane.showMessageDialog(RunTopComponent.this, msg, "Import canceled", JOptionPane.INFORMATION_MESSAGE);
                    log.info(msg);
                } else if (e instanceof RuntimeException) {
                    final String msg = "Error when exceuting import!";
                    JOptionPane.showMessageDialog(RunTopComponent.this, e.toString(), msg, JOptionPane.ERROR_MESSAGE);
                    addOutput(new OutputInitializing(msg, OutputInitializing.errorMessageFromThrowable(e)));
                    log.info(msg, e);
                    clearIntermedTable();

                } else if (!(e instanceof ExecutionException)) {
                    String msg = "Error: import to Intermed Table failed";
                    JOptionPane.showMessageDialog(RunTopComponent.this, msg + "\n(" + e.toString() + ")", "Error", JOptionPane.ERROR_MESSAGE);
                    log.error(msg, e);
                    addOutput(new OutputInitializing(msg, OutputInitializing.errorMessageFromThrowable(e)));
                    clearIntermedTable();
                }
            } finally {
                stopWait();
                if (lastInChain) {
                    if (res != null) {
                        setButtonsFilled();
                    } else {
                        setButtonsEmpty();
                    }
                }
                //IMPORTANT nullify all references to Importers to avoid classloader leaks!
                internalController = null;
            }

        }

        public boolean cancel() {
            final ExtractAndTransformController tmp = internalController;
            if (tmp != null) {
                tmp.cancel();
                return true;
            }
            return false;
        }
    }

    /**
     * Worker that creates an Importer (IMPORT STEP 1)
     */
    final class CreateWorker extends SwingWorker<ExtractAndTransformController, Void> {

        public CreateWorker(final boolean preview) {
            this(preview, true);
        }

        public CreateWorker(final boolean preview, final boolean lastInChain) {
            this.preview = preview;
            this.lastInChain = lastInChain;
        }
        private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
        private final boolean preview;
        private final boolean lastInChain;

        @Override
        protected ExtractAndTransformController doInBackground() throws Exception {
//            if (!mappings.allMappingsComplete()) {
//                throw new IllegalStateException("The mapping contains empty source contents on non-counter fields!");
//            }
            final ClassResourceProvider clp = getProject().getLookup().lookup(ClassResourceProvider.class);
            //create a new ImportController
            final ExtractAndTransformController ic = ControllerFactory.createExtractAndTransformController(clp, getImportRules());
            return ic;
        }

        @Override
        protected void done() {
            try {
                final ExtractAndTransformController imp = get();
                if (!preview) {
                    final String initLog = imp.getInitializeLog();
                    final String msg = "Import setting check successful";
                    addOutput(new OutputInitializing(initLog, msg));
                    JOptionPane.showMessageDialog(RunTopComponent.this, msg, "Check successful", JOptionPane.INFORMATION_MESSAGE);
                    log.info(msg);
                    //else close?
                }
            } catch (InterruptedException ex) {
                log.warn("Interrupted Exception", ex);
            } catch (ExecutionException ex) {
                final Throwable e = ex.getCause();
                final String msg = "Error while creating importer";
                JOptionPane.showMessageDialog(RunTopComponent.this, msg + "\n(" + e.toString() + ")", "Error", JOptionPane.ERROR_MESSAGE);
                log.error(msg, e);
                if (e instanceof InitializingException) {
                    final InitializingException ie = (InitializingException) e;
                    if (ie.getCause() instanceof DynamicCompilingException) {
                        final DynamicCompilingException dex = (DynamicCompilingException) ie.getCause();
                        final List<String> posErrs = dex.getPossibleErr();
                        mappings.markPotentialErrors(posErrs, 1);
                    }
                    for (final Point p : ie.getMappingErrorFields()) {
                        mappings.markPotentialError(p.x, p.y);
                    }
                    for (final Point p : ie.getReferenceErrorFields()) {
                        references.markPotentialError(p.x, p.y);
                    }
                    addOutput(new OutputInitializing(ie));
                }

            } finally {
                stopWait();
                if (lastInChain) {
                    setButtonsEmpty();
                }
            }
        }
    }
    // </editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Utility Classes">
    //-------------------------UTILITY CLASSES----------------------------------
    final static class ResolvableHelper implements Serializable {

        private static final long serialVersionUID = 1L;

        public Object readResolve() {
            return null;//RunTopComponent.getDefault();

        }
    }
//@clearing intermed
//    /**
//     * Takes care outFin all those documents, which need the intermediate table
//     * the be cleared if thy change.
//     */
//    class SpecificDocumentEventTracker implements DocumentListener {
//
//        private RunTopComponent rtc;
//        private Document[] docs;
//
//        public SpecificDocumentEventTracker(RunTopComponent rtc, CodeEditor ce) {
//            if (rtc != null && ce != null) {
//                this.rtc = rtc;
//                this.docs = ce.getDocuments();
//                if (docs != null) {
//                    for (Document d : docs) {
//                        if (d != null) {
//                            d.addDocumentListener(this);
//                        }
//                    }
//                }
//            }
//        }
//
//        public void insertUpdate(DocumentEvent e) {
//            rtc.clearIntermedTable();
//        }
//
//        public void removeUpdate(DocumentEvent e) {
//            rtc.clearIntermedTable();
//        }
//
//        public void changedUpdate(DocumentEvent e) {
//
//        }
//
//        public void destroy() {
//            if (docs != null) {
//                for (Document d : docs) {
//                    if (d != null) {
//                        d.removeDocumentListener(this);
//                    }
//                }
//            }
//        }
//    }
    }
// </editor-fold>





